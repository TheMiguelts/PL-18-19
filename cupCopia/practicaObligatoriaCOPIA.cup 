import java_cup.runtime.*;
import java.io.*;
import java.util.*;
parser code {:

public void syntax_error (Symbol s){
	System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	System.err.println("Error recuperado");
}

public void unrecovered_syntax_error(Symbol s){
	System.err.println("Error de sintaxis no recuperable");
}
:};
terminal String identificador, abrirP, cerrarP, abrirLl, cerrarLl, coma, vacio, entero, real,
puntoComa, opAsignacion, opMas, opMenos, opMultiplicacion, opDivision, opModulo, constEntera, cero, constReal,
constLit, estIf, estThen, estElse, estFor, estWhile, estDo, estUntil, estRepetir, opOr, opAnd, opNot, opIgual, opMenor,
opMayor, opMenorIgual, opMayorIgual, punto, cerrarC, abrirC, define, devolver, constRealExp, constRealMixto, to,
programa, variables, dosPuntos, constante, unit, begin, end, procedimiento, funcion, doPR, downto, enteroDecimal, realMixto, realExponencial, realDecimal,
constanteLiteral, escribir;

non terminal PRG, BLQ, DCLLIST, SENTLIST, DCL,
DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST,
DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM, TBAS,
SENT, ASIG, ID, EXP, OP, OPARIT, FACTOR, SUBPPARAMLIST,
EXPLIST, PROC_CALL, EXPCOND, OPLOG, FACTORCOND, OPCOMP,INC;
non terminal LAMBDA;


precedence right opMultiplicacion, opMas;
precedence right opMultiplicacion, opMenos;
precedence right opMultiplicacion, opModulo;
precedence right opDivision, opMas;
precedence right opDivision, opMenos;
precedence right opDivision, opModulo;
precedence right opAnd, opOr;

PRG::=programa identificador puntoComa BLQ:blq punto {:
		Programa p=new Programa();
		p.tipoPrograma=prog;
		p.nombre=identificador;
		p.bloque=blq;
		Programa.generarFichero(p.imprimir().toString());
		RESULT=p;
:}
    | unit identificador puntoComa DCLLIST:dcllist punto {:
		Programa p=new Programa();
		p.tipoPrograma=unit;
		p.bloque=dcllist;
		Programa.generarFichero(p.imprimir().toString());
		RESULT=p;
:}
;
BLQ ::= DCLLIST:dcllist begin SENTLIST:sentlist end;

DCLLIST ::= LAMBDA
    | DCLLIST:dcllist DCL:dcl;

SENTLIST ::= SENT:sent {:
		RESULT=sent;
    | SENTLIST:sentlist SENT:sent;

DCL ::= DEFCTE:defcte
    | DEFVAR:defvar
    | DEFPROC:defproc
    | DEFFUN:deffun;

DEFCTE ::= constante CTELIST:ctelist;

CTELIST ::= identificador opIgual SIMPVALUE:simpvalue puntoComa
    | CTELIST:ctelist identificador opIgual SIMPVALUE:simpvalue puntoComa;

SIMPVALUE ::= constEntera:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.valorConstante=cte;
		RESULT=s;
:}		
    | constReal:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.valorConstante=cte;
		RESULT=s;
:}
    | constLit:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.esValorConstante=cte;
		RESULT=s;
:}
;

DEFVAR ::= variables DEFVARLIST:defvarlist puntoComa;

DEFVARLIST ::= VARLIST:varlist dosPuntos TBAS:tbas
    | DEFVARLIST:defvarlist puntoComa VARLIST:varlist dosPuntos TBAS:tbas;

VARLIST ::= identificador
    | identificador coma VARLIST:varlist;

DEFPROC ::= procedimiento identificador FORMAL_PARAMLIST:formalParamList puntoComa BLQ:blq puntoComa;

DEFFUN ::= funcion identificador FORMAL_PARAMLIST:formalParamList dosPuntos TBAS:tbas puntoComa BLQ:blq puntoComa;

FORMAL_PARAMLIST ::= LAMBDA
    | abrirP FORMAL_PARAM:formalParam cerrarP;

FORMAL_PARAM ::= VARLIST:varlist dosPuntos TBAS:tbas
    | VARLIST:varlist dosPuntos TBAS:tbas puntoComa FORMAL_PARAM:formalParam;

TBAS ::= entero {:
		Simbolo s=new Simbolo();
		s.esTipado=true;
		s.tipo="INTEGER";
		RESULT=s;
:}
    | real {:
		Simbolo s=new Simbolo();
		s.esTipado=true;
		s.tipo="REAL";
		RESULT=s;
:}
;

SENT ::= ASIG:asig puntoComa
    | PROC_CALL:proCall puntoComa
    | estIf EXPCOND:expcond estThen BLQ:blq estElse BLQ:blq2
    | estWhile EXPCOND:expcond estDo BLQ:blq
    | estRepetir BLQ:blq estUntil EXPCOND:expcond puntoComa
    | estFor identificador opAsignacion EXP:exp INC:inc EXP:exp2 doPR BLQ:blq;

ASIG ::= ID:id opAsignacion EXP:exp;

ID ::= identificador;

EXP ::= EXP:exp OP:op EXP:exp2
    | FACTOR:factor;

OP ::= OPARIT:oparit;

OPARIT ::= opMas {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="+";
		RESULT=s;
:}
    | opMenos {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="-";
		RESULT=s;
:}
    | opMultiplicacion {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="*";
		RESULT=s;
:}
    | opDivision {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="DIV";
		RESULT=s;
:}
    | opModulo {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="MOD";
		RESULT=s;
:}
;

FACTOR ::= SIMPVALUE:simpvalue
    | abrirP EXP:exp cerrarP
    | identificador SUBPPARAMLIST:subparamlist;

SUBPPARAMLIST ::= LAMBDA
    | abrirP EXPLIST:explist cerrarP;

EXPLIST ::= EXP:exp
    | EXP:exp coma EXPLIST:explist;

PROC_CALL ::= identificador SUBPPARAMLIST:subparamlist;

EXPCOND ::= EXPCOND:expcond OPLOG:oplog EXPCOND:expcond2
    | FACTORCOND:factorcond;

OPLOG ::= opOr {:
		Simbolo s=new SÃ­mbolo();
		s.esOperacionLogica=true;
		s.tipoOperacionLogica="||";
		RESULT=s;
:}
    | opAnd {:
		Simbolo s=new Simbolo();
		s.esOperacionLogica=true;
		s.tipoOperacionLogica="&&";
		RESULT=s;
:}
;

FACTORCOND ::= EXP:exp1 OPCOMP:opcomp EXP:exp2 {:
		Simbolo s=new Simbolo();
		s=opcomp;
		Sentencia cf=new Sentencia();
		cf.condicion.addAll(exp1.simbolos);
		cf.condicion.add(opr);
		cf.condicion.addAll(exp2.simbolos);
		RESULT=cf;
:}
    | abrirP EXP:exp cerrarP {:
		RESULT=exp;
:}
    | opNot FACTORCOND:factorcond;

OPCOMP ::= opMenor {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="<";
		RESULT=s;
:}
    | opMayor {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion=">";
		RESULT=s;
:}
    | opMenorIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="<=";
		RESULT=s;
:}
    | opMayorIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion=">=";
		RESULT=s;
:}
    | opIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="==";
		RESULT=s;
:};

INC ::= to {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=false;
		s.tipoOperacion="++";
		RESULT=s;
:}
    | downto {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=false;
		s.tipoOperacion="--";
		RESULT=s;
:}
; 
LAMBDA ::= ;
