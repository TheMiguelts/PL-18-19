import java_cup.runtime.*;
import java.io.*;
import java.util.*;
parser code {:

public void syntax_error (Symbol s){
	System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	System.err.println("Error recuperado");
}

public void unrecovered_syntax_error(Symbol s){
	System.err.println("Error de sintaxis no recuperable");
}
:};
terminal String identificador, abrirP, cerrarP, abrirLl, cerrarLl, coma, vacio, entero, real,
puntoComa, opAsignacion, opMas, opMenos, opMultiplicacion, opDivision, opModulo, constEntera, cero, constReal,
constLit, estIf, estThen, estElse, estFor, estWhile, estDo, estUntil, estRepetir, opOr, opAnd, opNot, opIgual, opMenor,
opMayor, opMenorIgual, opMayorIgual, punto, cerrarC, abrirC, define, devolver, constRealExp, constRealMixto, to,
programa, variables, dosPuntos, constante, unit, begin, end, procedimiento, funcion, doPR, downto, enteroDecimal, realMixto, realExponencial, realDecimal,
constanteLiteral, escribir;

non terminal PRG, BLQ, DCLLIST, SENTLIST, DCL,
DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST,
DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM, TBAS,
SENT, ASIG, ID, EXP, OP, OPARIT, FACTOR, SUBPPARAMLIST,
EXPLIST, PROC_CALL, EXPCOND, OPLOG, FACTORCOND, OPCOMP,INC;
non terminal LAMBDA;


precedence right opMultiplicacion, opMas;
precedence right opMultiplicacion, opMenos;
precedence right opMultiplicacion, opModulo;
precedence right opDivision, opMas;
precedence right opDivision, opMenos;
precedence right opDivision, opModulo;
precedence right opAnd, opOr;

PRG::=programa identificador puntoComa BLQ:blq punto {:
		Programa p=new Programa();
		p.tipoPrograma=prog;
		p.nombre=identificador;
		p.bloque=blq;
		Programa.generarFichero(p.imprimir().toString());
		RESULT=p;
:}
    | unit identificador puntoComa DCLLIST:dcllist punto {:
		Programa p=new Programa();
		p.tipoPrograma=unit;
		p.bloque=dcllist;
		Programa.generarFichero(p.imprimir().toString());
		RESULT=p;
:}
;
BLQ ::= DCLLIST:dcllist begin SENTLIST:sentlist end;

DCLLIST ::= LAMBDA
    | DCLLIST:dcllist DCL:dcl;

SENTLIST ::= SENT:sent {:
		RESULT=sent;
    | SENTLIST:sentlist SENT:sent;

DCL ::= DEFCTE:defcte
    | DEFVAR:defvar
    | DEFPROC:defproc
    | DEFFUN:deffun;

DEFCTE ::= constante CTELIST:ctelist;

CTELIST ::= identificador opIgual SIMPVALUE:simpvalue puntoComa
    | CTELIST:ctelist identificador opIgual SIMPVALUE:simpvalue puntoComa;

SIMPVALUE ::= constEntera:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.valorConstante=cte;
		RESULT=s;
:}		
    | constReal:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.valorConstante=cte;
		RESULT=s;
:}
    | constLit:cte {:
		Simbolo s=new Simbolo();
		s.esConstante=true;
		s.esValorConstante=cte;
		RESULT=s;
:}
;

DEFVAR ::= variables DEFVARLIST:defvarlist puntoComa {:
			Bloque b = new Bloque();
			Simbolo s = new Simbolo();
			s.tipo = puntoComa;
			s.valor = ";";
			
			defvarlist.simbolos.add(s);
			b.sentencias.add(defvarlist);
			RESULT = b;
			:}
			;

DEFVARLIST ::= VARLIST:varlist dosPuntos TBAS:tbas {:
    | DEFVARLIST:defvarlist puntoComa VARLIST:varlist dosPuntos TBAS:tbas;

VARLIST ::= identificador {:
			Lista l = new Lista();
			Simbolo s = new Simbolo();
			s.tipo = identificador;
			s.valor = i;
			
			l.simbolos.add(s);
			RESULT = l;
			:}
    | identificador coma VARLIST:varlist {:
			Lista l = new Lista();
			Simbolo s = new Simbolo();
			s.tipo = identificador;
			s.valor = identificador;
			Simbolo s = new Simbolo();
			s.tipo = coma;
			s.valor = ",";

			l.simbolos.add(s);
			l.simbolos.add(s);
			l.simbolos.addAll(vl.simbolos);
			RESULT = l;
			:};


DEFPROC ::= procedimiento identificador FORMAL_PARAMLIST:formalParamList puntoComa BLQ:blq puntoComa;

DEFFUN ::= funcion identificador FORMAL_PARAMLIST:formalParamList dosPuntos TBAS:tbas puntoComa BLQ:blq puntoComa;

FORMAL_PARAMLIST ::= LAMBDA {:
						Lista l = new Lista();
						Simbolo s = new Simbolo();
						s.tipo = tipo;
						
						l.simbolos.add(s);
						RESULT = l;
						:}
    | abrirP FORMAL_PARAM:formalParam cerrarP {:
					Lista l = new Lista();
					Simbolo s = new Simbolo();
					s.tipo = abrirP;
					s.valor = "(";
					Simbolo s2= new Simbolo();
					s2.tipo = cerrarP;
					s2.valor = ")";
					
					l.simbolos.add(s);
					l.simbolos.addAll(formalParam.simbolos);
					l.simbolos.add(s2);
					
					RESULT = l;
					:};

FORMAL_PARAM ::= VARLIST:varlist dosPuntos TBAS:tbas {:
								Lista l = new Lista();
								Simbolo s = new Simbolo();
								s.tipo = punto;
								s.valor = ".";
								
								l.simbolos.add(t);
								l.simbolos.addAll(varlist.simbolos);
								l.simbolos.add(s);
								RESULT = l;
								:}
    | VARLIST:varlist dosPuntos TBAS:tbas puntoComa FORMAL_PARAM:formalParam {:
								Lista l = new Lista();
								Simbolo s = new Simbolo();
								s.tipo = punto;
								s.valor = ".";
								Simbolo s2 = new Simbolo();
								s2.tipo = coma;
								s2.valor = ",";
									
								l.simbolos.add(s);
								l.simbolos.addAll(varlist.simbolos);
								l.simbolos.add(s2);
								l.simbolos.addAll(formalParam.simbolos);
								RESULT = l;
								:};

TBAS ::= entero {:
		Simbolo s=new Simbolo();
		s.esTipado=true;
		s.tipo="INTEGER";
		RESULT=s;
:}
    | real {:
		Simbolo s=new Simbolo();
		s.esTipado=true;
		s.tipo="REAL";
		RESULT=s;
:}
;

SENT ::= ASIG:asig puntoComa
    | PROC_CALL:proCall puntoComa
    | estIf EXPCOND:expcond estThen BLQ:blq estElse BLQ:blq2
    | estWhile EXPCOND:expcond estDo BLQ:blq
    | estRepetir BLQ:blq estUntil EXPCOND:expcond puntoComa
    | estFor identificador opAsignacion EXP:exp INC:inc EXP:exp2 doPR BLQ:blq;

ASIG ::= ID:id opAsignacion EXP:exp;

ID ::= identificador;

EXP ::= EXP:exp OP:op EXP:exp2
    | FACTOR:factor;

OP ::= OPARIT:oparit;

OPARIT ::= opMas {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="+";
		RESULT=s;
:}
    | opMenos {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="-";
		RESULT=s;
:}
    | opMultiplicacion {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="*";
		RESULT=s;
:}
    | opDivision {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="DIV";
		RESULT=s;
:}
    | opModulo {:
		Simbolo s=new Simbolo();
		s.esOperacionAritmetica=true;
		s.tipoOperacionAritmetica="MOD";
		RESULT=s;
:}
;

FACTOR ::= SIMPVALUE:simpvalue
    | abrirP EXP:exp cerrarP
    | identificador SUBPPARAMLIST:subparamlist;

SUBPPARAMLIST ::= LAMBDA
    | abrirP EXPLIST:explist cerrarP;

EXPLIST ::= EXP:exp
    | EXP:exp coma EXPLIST:explist;

PROC_CALL ::= identificador SUBPPARAMLIST:subparamlist;

EXPCOND ::= EXPCOND:expcond OPLOG:oplog EXPCOND:expcond2
    | FACTORCOND:factorcond;

OPLOG ::= opOr {:
		Simbolo s=new SÃ­mbolo();
		s.esOperacionLogica=true;
		s.tipoOperacionLogica="||";
		RESULT=s;
:}
    | opAnd {:
		Simbolo s=new Simbolo();
		s.esOperacionLogica=true;
		s.tipoOperacionLogica="&&";
		RESULT=s;
:}
;

FACTORCOND ::= EXP:exp1 OPCOMP:opcomp EXP:exp2 {:
		Simbolo s=new Simbolo();
		s=opcomp;
		Sentencia cf=new Sentencia();
		cf.condicion.addAll(exp1.simbolos);
		cf.condicion.add(opr);
		cf.condicion.addAll(exp2.simbolos);
		RESULT=cf;
:}
    | abrirP EXP:exp cerrarP {:
		RESULT=exp;
:}
    | opNot FACTORCOND:factorcond;

OPCOMP ::= opMenor {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="<";
		RESULT=s;
:}
    | opMayor {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion=">";
		RESULT=s;
:}
    | opMenorIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="<=";
		RESULT=s;
:}
    | opMayorIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion=">=";
		RESULT=s;
:}
    | opIgual {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=true;
		s.tipoOperacion="==";
		RESULT=s;
:};

INC ::= to {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=false;
		s.tipoOperacion="++";
		RESULT=s;
:}
    | downto {:
		Simbolo s=new Simbolo();
		s.esOperacionComp=false;
		s.tipoOperacion="--";
		RESULT=s;
:}
; 
LAMBDA ::= ;
